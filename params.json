{"body":"# factory_girl [![Build Status](https://secure.travis-ci.org/thoughtbot/factory_girl.png)](http://travis-ci.org/thoughtbot/factory_girl?branch=master) [![Dependency Status](https://gemnasium.com/thoughtbot/factory_girl.png)](https://gemnasium.com/thoughtbot/factory_girl)\r\n\r\nfactory_girl is a fixtures replacement with a straightforward definition syntax, support for multiple build strategies (saved instances, unsaved instances, attribute hashes, and stubbed objects), and support for multiple factories for the same class (user, admin_user, and so on), including factory inheritance.\r\n\r\nIf you want to use factory_girl with Rails, see\r\n[factory_girl_rails](https://github.com/thoughtbot/factory_girl_rails).\r\n\r\nDocumentation\r\n-------------\r\n\r\nYou should find the documentation for your version of factory_girl on [Rubygems](https://rubygems.org/gems/factory_girl).\r\n\r\nSee [GETTING_STARTED](https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md) for information on defining and using factories.\r\n\r\nInstall\r\n--------\r\n\r\n```shell\r\ngem install factory_girl\r\n```\r\nor add the following line to Gemfile:\r\n\r\n```ruby\r\ngem 'factory_girl'\r\n```\r\nand run `bundle install` from your shell.\r\n\r\nSupported Ruby versions\r\n-----------------------\r\n\r\nThe FactoryGirl 3.x+ series supports MRI Ruby 1.9. Additionally, FactoryGirl\r\n3.6+ supports JRuby 1.6.7.2+ while running in 1.9 mode. See\r\n[GETTING_STARTED](https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md)\r\nfor more information on configuring the JRuby environment.\r\n\r\nFor versions of Ruby prior to 1.9, please use FactoryGirl 2.x.\r\n\r\nMore Information\r\n----------------\r\n\r\n* [Rubygems](https://rubygems.org/gems/factory_girl)\r\n* [Mailing list](http://groups.google.com/group/factory_girl)\r\n* [Issues](https://github.com/thoughtbot/factory_girl/issues)\r\n* [GIANT ROBOTS SMASHING INTO OTHER GIANT ROBOTS](http://robots.thoughtbot.com/)\r\n\r\nContributing\r\n------------\r\n\r\nPlease see the [contribution guidelines](https://github.com/thoughtbot/factory_girl/blob/master/CONTRIBUTION_GUIDELINES.md).\r\n\r\nCredits\r\n-------\r\n\r\nfactory_girl was written by Joe Ferris with contributions from several authors, including:\r\n\r\n* Alex Sharp\r\n* Eugene Bolshakov\r\n* Jon Yurek\r\n* Josh Nichols\r\n* Josh Owens\r\n* Nate Sutton\r\n* Josh Clayton\r\n* Thomas Walpole\r\n\r\n![thoughtbot](http://thoughtbot.com/images/tm/logo.png)\r\n\r\nfactory_girl is maintained and funded by [thoughtbot, inc](http://thoughtbot.com/community)\r\n\r\nThe names and logos for thoughtbot are trademarks of thoughtbot, inc.\r\n\r\nLicense\r\n-------\r\n\r\nfactory_girl is Copyright Â© 2008-2012 Joe Ferris and thoughtbot. It is free software, and may be redistributed under the terms specified in the LICENSE file.\r\n\r\nGetting Started\r\n===============\r\n\r\nUpdate Your Gemfile\r\n-------------------\r\n\r\nIf you're using Rails, you'll need to change the required version of `factory_girl_rails`:\r\n\r\n```ruby\r\ngem \"factory_girl_rails\", \"~> 4.0\"\r\n```\r\n\r\nIf you're *not* using Rails, you'll just have to change the required version of `factory_girl`:\r\n\r\n```ruby\r\ngem \"factory_girl\", \"~> 4.0\"\r\n```\r\n\r\nJRuby users: FactoryGirl works with JRuby starting with 1.6.7.2 (latest stable, as per July 2012).\r\nJRuby has to be used in 1.9 mode, for that, use JRUBY_OPTS environment variable:\r\n\r\n```\r\nexport JRUBY_OPTS=--1.9\r\n```\r\n\r\nOnce your Gemfile is updated, you'll want to update your bundle.\r\n\r\nUsing Without Bundler\r\n---------------------\r\n\r\nIf you're not using Bundler, be sure to have the gem installed and call:\r\n\r\n```\r\nrequire 'factory_girl'\r\n```\r\n\r\nOnce required, assuming you have a directory structure of `spec/factories` or\r\n`test/factories`, all you'll need to do is run\r\n\r\n```ruby\r\nFactoryGirl.find_definitions\r\n```\r\n\r\nIf you're using a separate directory structure for your factories, you can\r\nchange the definition file paths before trying to find definitions:\r\n\r\n```ruby\r\nFactoryGirl.definition_file_paths = %w(custom_factories_directory)\r\nFactoryGirl.find_definitions\r\n```\r\n\r\nIf you don't have a separate directory of factories and would like to define\r\nthem inline, that's possible as well:\r\n\r\n```ruby\r\nrequire 'factory_girl'\r\n\r\nFactoryGirl.define do\r\n  factory :user do\r\n    name 'John Doe'\r\n    date_of_birth { 21.years.ago }\r\n  end\r\nend\r\n```\r\n\r\nDefining factories\r\n------------------\r\n\r\nEach factory has a name and a set of attributes. The name is used to guess the class of the object by default, but it's possible to explicitly specify it:\r\n\r\n```ruby\r\n# This will guess the User class\r\nFactoryGirl.define do\r\n  factory :user do\r\n    first_name \"John\"\r\n    last_name  \"Doe\"\r\n    admin false\r\n  end\r\n\r\n  # This will use the User class (Admin would have been guessed)\r\n  factory :admin, class: User do\r\n    first_name \"Admin\"\r\n    last_name  \"User\"\r\n    admin      true\r\n  end\r\nend\r\n```\r\n\r\nIt is highly recommended that you have one factory for each class that provides the simplest set of attributes necessary to create an instance of that class. If you're creating ActiveRecord objects, that means that you should only provide attributes that are required through validations and that do not have defaults. Other factories can be created through inheritance to cover common scenarios for each class.\r\n\r\nAttempting to define multiple factories with the same name will raise an error.\r\n\r\nFactories can be defined anywhere, but will be automatically loaded if they\r\nare defined in files at the following locations:\r\n\r\n    test/factories.rb\r\n    spec/factories.rb\r\n    test/factories/*.rb\r\n    spec/factories/*.rb\r\n\r\nUsing factories\r\n---------------\r\n\r\nfactory\\_girl supports several different build strategies: build, create, attributes\\_for and build\\_stubbed:\r\n\r\n```ruby\r\n# Returns a User instance that's not saved\r\nuser = FactoryGirl.build(:user)\r\n\r\n# Returns a saved User instance\r\nuser = FactoryGirl.create(:user)\r\n\r\n# Returns a hash of attributes that can be used to build a User instance\r\nattrs = FactoryGirl.attributes_for(:user)\r\n\r\n# Returns an object with all defined attributes stubbed out\r\nstub = FactoryGirl.build_stubbed(:user)\r\n\r\n# Passing a block to any of the methods above will yield the return object\r\nFactoryGirl.create(:user) do |user|\r\n  user.posts.create(attributes_for(:post))\r\nend\r\n```\r\n\r\nNo matter which strategy is used, it's possible to override the defined attributes by passing a hash:\r\n\r\n```ruby\r\n# Build a User instance and override the first_name property\r\nuser = FactoryGirl.build(:user, first_name: \"Joe\")\r\nuser.first_name\r\n# => \"Joe\"\r\n```\r\n\r\nIf repeating \"FactoryGirl\" is too verbose for you, you can mix the syntax methods in:\r\n\r\n```ruby\r\n# rspec\r\nRSpec.configure do |config|\r\n  config.include FactoryGirl::Syntax::Methods\r\nend\r\n\r\n# Test::Unit\r\nclass Test::Unit::TestCase\r\n  include FactoryGirl::Syntax::Methods\r\nend\r\n\r\n# Cucumber\r\nWorld(FactoryGirl::Syntax::Methods)\r\n\r\n# MiniTest\r\nclass MiniTest::Unit::TestCase\r\n  include FactoryGirl::Syntax::Methods\r\nend\r\n\r\n# MiniTest::Spec\r\nclass MiniTest::Spec\r\n  include FactoryGirl::Syntax::Methods\r\nend\r\n\r\n# minitest-rails\r\nclass MiniTest::Rails::ActiveSupport::TestCase\r\n  include FactoryGirl::Syntax::Methods\r\nend\r\n```\r\n\r\nThis allows you to use the core set of syntax methods (`build`,\r\n`build_stubbed`, `create`, `attributes_for`, and their `*_list` counterparts)\r\nwithout having to call them on FactoryGirl directly:\r\n\r\n```ruby\r\ndescribe User, \"#full_name\" do\r\n  subject { create(:user, first_name: \"John\", last_name: \"Doe\") }\r\n\r\n  its(:full_name) { should == \"John Doe\" }\r\nend\r\n```\r\n\r\nLazy Attributes\r\n---------------\r\n\r\nMost factory attributes can be added using static values that are evaluated when\r\nthe factory is defined, but some attributes (such as associations and other\r\nattributes that must be dynamically generated) will need values assigned each\r\ntime an instance is generated. These \"lazy\" attributes can be added by passing a\r\nblock instead of a parameter:\r\n\r\n```ruby\r\nfactory :user do\r\n  # ...\r\n  activation_code { User.generate_activation_code }\r\n  date_of_birth   { 21.years.ago }\r\nend\r\n```\r\n\r\nIn addition to running other methods dynamically, you can use FactoryGirl's\r\nsyntax methods (like `build`, `create`, and `generate`) within dynamic\r\nattributes without having to prefix the call with `FactoryGirl.`. This allows\r\nyou to do:\r\n\r\n```ruby\r\nsequence(:random_string) {|n| LoremIpsum.generate }\r\n\r\nfactory :post do\r\n  title { generate(:random_string) } # instead of FactoryGirl.generate(:random_string)\r\nend\r\n\r\nfactory :comment do\r\n  post\r\n  body { generate(:random_string) }  # instead of FactoryGirl.generate(:random_string)\r\nend\r\n```\r\n\r\nAliases\r\n-------\r\n\r\nAliases allow you to use named associations more easily.\r\n\r\n```ruby\r\nfactory :user, aliases: [:author, :commenter] do\r\n  first_name    \"John\"\r\n  last_name     \"Doe\"\r\n  date_of_birth { 18.years.ago }\r\nend\r\n\r\nfactory :post do\r\n  author\r\n  # instead of\r\n  # association :author, factory: :user\r\n  title \"How to read a book effectively\"\r\n  body  \"There are five steps involved.\"\r\nend\r\n\r\nfactory :comment do\r\n  commenter\r\n  # instead of\r\n  # association :commenter, factory: :user\r\n  body \"Great article!\"\r\nend\r\n```\r\n\r\nDependent Attributes\r\n--------------------\r\n\r\nAttributes can be based on the values of other attributes using the evaluator that is yielded to lazy attribute blocks:\r\n\r\n```ruby\r\nfactory :user do\r\n  first_name \"Joe\"\r\n  last_name  \"Blow\"\r\n  email { \"#{first_name}.#{last_name}@example.com\".downcase }\r\nend\r\n\r\nFactoryGirl.create(:user, last_name: \"Doe\").email\r\n# => \"joe.doe@example.com\"\r\n```\r\n\r\nTransient Attributes\r\n--------------------\r\n\r\nThere may be times where your code can be DRYed up by passing in transient attributes to factories.\r\n\r\n```ruby\r\nfactory :user do\r\n  ignore do\r\n    rockstar true\r\n    upcased  false\r\n  end\r\n\r\n  name  { \"John Doe#{\" - Rockstar\" if rockstar}\" }\r\n  email { \"#{name.downcase}@example.com\" }\r\n\r\n  after(:create) do |user, evaluator|\r\n    user.name.upcase! if evaluator.upcased\r\n  end\r\nend\r\n\r\nFactoryGirl.create(:user, upcased: true).name\r\n#=> \"JOHN DOE - ROCKSTAR\"\r\n```\r\n\r\nStatic and dynamic attributes can be ignored. Ignored attributes will be ignored\r\nwithin attributes\\_for and won't be set on the model, even if the attribute\r\nexists or you attempt to override it.\r\n\r\nWithin FactoryGirl's dynamic attributes, you can access ignored attributes as\r\nyou would expect. If you need to access the evaluator in a FactoryGirl callback,\r\nyou'll need to declare a second block argument (for the evaluator) and access\r\nignored attributes from there.\r\n\r\nAssociations\r\n------------\r\n\r\nIt's possible to set up associations within factories. If the factory name is the same as the association name, the factory name can be left out.\r\n\r\n```ruby\r\nfactory :post do\r\n  # ...\r\n  author\r\nend\r\n```\r\n\r\nYou can also specify a different factory or override attributes:\r\n\r\n```ruby\r\nfactory :post do\r\n  # ...\r\n  association :author, factory: :user, last_name: \"Writely\"\r\nend\r\n```\r\n\r\nThe behavior of the association method varies depending on the build strategy used for the parent object.\r\n\r\n```ruby\r\n# Builds and saves a User and a Post\r\npost = FactoryGirl.create(:post)\r\npost.new_record?        # => false\r\npost.author.new_record? # => false\r\n\r\n# Builds and saves a User, and then builds but does not save a Post\r\npost = FactoryGirl.build(:post)\r\npost.new_record?        # => true\r\npost.author.new_record? # => false\r\n```\r\n\r\nTo not save the associated object, specify strategy: :build in the factory:\r\n\r\n```ruby\r\nfactory :post do\r\n  # ...\r\n  association :author, factory: :user, strategy: :build\r\nend\r\n\r\n# Builds a User, and then builds a Post, but does not save either\r\npost = FactoryGirl.build(:post)\r\npost.new_record?        # => true\r\npost.author.new_record? # => true\r\n```\r\n\r\nPlease note that the `strategy: :build` option must be passed to an explicit call to `association`,\r\nand cannot be used with implicit associations:\r\n\r\n```ruby\r\nfactory :post do\r\n  # ...\r\n  author strategy: :build    # <<< this does *not* work; causes author_id to be nil\r\n```\r\n\r\nGenerating data for a `has_many` relationship is a bit more involved,\r\ndepending on the amount of flexibility desired, but here's a surefire example\r\nof generating associated data.\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n\r\n  # post factory with a `belongs_to` association for the user\r\n  factory :post do\r\n    title \"Through the Looking Glass\"\r\n    user\r\n  end\r\n\r\n  # user factory without associated posts\r\n  factory :user do\r\n    name \"John Doe\"\r\n\r\n    # user_with_posts will create post data after the user has been created\r\n    factory :user_with_posts do\r\n      # posts_count is declared as an ignored attribute and available in\r\n      # attributes on the factory, as well as the callback via the evaluator\r\n      ignore do\r\n        posts_count 5\r\n      end\r\n\r\n      # the after(:create) yields two values; the user instance itself and the\r\n      # evaluator, which stores all values from the factory, including ignored\r\n      # attributes; `create_list`'s second argument is the number of records\r\n      # to create and we make sure the user is associated properly to the post\r\n      after(:create) do |user, evaluator|\r\n        FactoryGirl.create_list(:post, evaluator.posts_count, user: user)\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis allows us to do:\r\n\r\n```ruby\r\nFactoryGirl.create(:user).posts.length # 0\r\nFactoryGirl.create(:user_with_posts).posts.length # 5\r\nFactoryGirl.create(:user_with_posts, posts_count: 15).posts.length # 15\r\n```\r\n\r\nInheritance\r\n-----------\r\n\r\nYou can easily create multiple factories for the same class without repeating common attributes by nesting factories:\r\n\r\n```ruby\r\nfactory :post do\r\n  title \"A title\"\r\n\r\n  factory :approved_post do\r\n    approved true\r\n  end\r\nend\r\n\r\napproved_post = FactoryGirl.create(:approved_post)\r\napproved_post.title    # => \"A title\"\r\napproved_post.approved # => true\r\n```\r\n\r\nYou can also assign the parent explicitly:\r\n\r\n```ruby\r\nfactory :post do\r\n  title \"A title\"\r\nend\r\n\r\nfactory :approved_post, parent: :post do\r\n  approved true\r\nend\r\n```\r\n\r\nAs mentioned above, it's good practice to define a basic factory for each class\r\nwith only the attributes required to create it. Then, create more specific\r\nfactories that inherit from this basic parent. Factory definitions are still\r\ncode, so keep them DRY.\r\n\r\nSequences\r\n---------\r\n\r\nUnique values in a specific format (for example, e-mail addresses) can be\r\ngenerated using sequences. Sequences are defined by calling sequence in a\r\ndefinition block, and values in a sequence are generated by calling\r\nFactoryGirl.generate:\r\n\r\n```ruby\r\n# Defines a new sequence\r\nFactoryGirl.define do\r\n  sequence :email do |n|\r\n    \"person#{n}@example.com\"\r\n  end\r\nend\r\n\r\nFactoryGirl.generate :email\r\n# => \"person1@example.com\"\r\n\r\nFactoryGirl.generate :email\r\n# => \"person2@example.com\"\r\n```\r\n\r\nSequences can be used as attributes:\r\n\r\n```ruby\r\nfactory :user do\r\n  email\r\nend\r\n```\r\n\r\nOr in lazy attributes:\r\n\r\n```ruby\r\nfactory :invite do\r\n  invitee { generate(:email) }\r\nend\r\n```\r\n\r\nAnd it's also possible to define an in-line sequence that is only used in\r\na particular factory:\r\n\r\n```ruby\r\nfactory :user do\r\n  sequence(:email) {|n| \"person#{n}@example.com\" }\r\nend\r\n```\r\n\r\nYou can also override the initial value:\r\n\r\n```ruby\r\nfactory :user do\r\n  sequence(:email, 1000) {|n| \"person#{n}@example.com\" }\r\nend\r\n```\r\n\r\nWithout a block, the value will increment itself, starting at its initial value:\r\n\r\n```ruby\r\nfactory :post do\r\n  sequence(:position)\r\nend\r\n```\r\n\r\nSequences can also have aliases. The sequence aliases share the same counter:\r\n\r\n```ruby\r\nfactory :user do\r\n  sequence(:email, 1000, aliases: [:sender, :receiver]) {|n| \"person#{n}@example.com\" }\r\nend\r\n\r\n# will increase value counter for :email which is shared by :sender and :receiver\r\nFactoryGirl.next(:sender)\r\n```\r\n\r\nDefine aliases and use default value (1) for the counter\r\n\r\n```ruby\r\nfactory :user do\r\n  sequence(:email, aliases: [:sender, :receiver]) {|n| \"person#{n}@example.com\" }\r\nend\r\n```\r\n\r\nSetting the value:\r\n\r\n```ruby\r\nfactory :user do\r\n  sequence(:email, 'a', aliases: [:sender, :receiver]) {|n| \"person#{n}@example.com\" }\r\nend\r\n```\r\n\r\nThe value just needs to support the `#next` method. Here the next value will be 'a', then 'b', etc.\r\n\r\nTraits\r\n------\r\n\r\nTraits allow you to group attributes together and then apply them\r\nto any factory.\r\n\r\n```ruby\r\nfactory :user, aliases: [:author]\r\n\r\nfactory :story do\r\n  title \"My awesome story\"\r\n  author\r\n\r\n  trait :published do\r\n    published true\r\n  end\r\n\r\n  trait :unpublished do\r\n    published false\r\n  end\r\n\r\n  trait :week_long_publishing do\r\n    start_at { 1.week.ago }\r\n    end_at   { Time.now }\r\n  end\r\n\r\n  trait :month_long_publishing do\r\n    start_at { 1.month.ago }\r\n    end_at   { Time.now }\r\n  end\r\n\r\n  factory :week_long_published_story,    traits: [:published, :week_long_publishing]\r\n  factory :month_long_published_story,   traits: [:published, :month_long_publishing]\r\n  factory :week_long_unpublished_story,  traits: [:unpublished, :week_long_publishing]\r\n  factory :month_long_unpublished_story, traits: [:unpublished, :month_long_publishing]\r\nend\r\n```\r\n\r\nTraits can be used as attributes:\r\n\r\n```ruby\r\nfactory :week_long_published_story_with_title, parent: :story do\r\n  published\r\n  week_long_publishing\r\n  title { \"Publishing that was started at {start_at}\" }\r\nend\r\n```\r\n\r\nTraits that define the same attributes won't raise AttributeDefinitionErrors;\r\nthe trait that defines the attribute latest gets precedence.\r\n\r\n```ruby\r\nfactory :user do\r\n  name \"Friendly User\"\r\n  login { name }\r\n\r\n  trait :male do\r\n    name   \"John Doe\"\r\n    gender \"Male\"\r\n    login { \"#{name} (M)\" }\r\n  end\r\n\r\n  trait :female do\r\n    name   \"Jane Doe\"\r\n    gender \"Female\"\r\n    login { \"#{name} (F)\" }\r\n  end\r\n\r\n  trait :admin do\r\n    admin true\r\n    login { \"admin-#{name}\" }\r\n  end\r\n\r\n  factory :male_admin,   traits: [:male, :admin]   # login will be \"admin-John Doe\"\r\n  factory :female_admin, traits: [:admin, :female] # login will be \"Jane Doe (F)\"\r\nend\r\n```\r\n\r\nYou can also override individual attributes granted by a trait in subclasses.\r\n\r\n```ruby\r\nfactory :user do\r\n  name \"Friendly User\"\r\n  login { name }\r\n\r\n  trait :male do\r\n    name   \"John Doe\"\r\n    gender \"Male\"\r\n    login { \"#{name} (M)\" }\r\n  end\r\n\r\n  factory :brandon do\r\n    male\r\n    name \"Brandon\"\r\n  end\r\nend\r\n```\r\n\r\nTraits can also be passed in as a list of symbols when you construct an instance from FactoryGirl.\r\n\r\n```ruby\r\nfactory :user do\r\n  name \"Friendly User\"\r\n\r\n  trait :male do\r\n    name   \"John Doe\"\r\n    gender \"Male\"\r\n  end\r\n\r\n  trait :admin do\r\n    admin true\r\n  end\r\nend\r\n\r\n# creates an admin user with gender \"Male\" and name \"Jon Snow\"\r\nFactoryGirl.create(:user, :admin, :male, name: \"Jon Snow\")\r\n```\r\n\r\nThis ability works with `build`, `build_stubbed`, `attributes_for`, and `create`.\r\n\r\n`create_list` and `build_list` methods are supported as well. Just remember to pass\r\nthe number of instances to create/build as second parameter, as documented in the\r\n\"Building or Creating Multiple Records\" section of this file.\r\n\r\n```ruby\r\nfactory :user do\r\n  name \"Friendly User\"\r\n\r\n  trait :admin do\r\n    admin true\r\n  end\r\nend\r\n\r\n# creates 3 admin users with gender \"Male\" and name \"Jon Snow\"\r\nFactoryGirl.create_list(:user, 3, :admin, :male, name: \"Jon Snow\")\r\n```\r\n\r\nTraits can be used with associations easily too:\r\n\r\n```ruby\r\nfactory :user do\r\n  name \"Friendly User\"\r\n\r\n  trait :admin do\r\n    admin true\r\n  end\r\nend\r\n\r\nfactory :post do\r\n  association :user, :admin, name: 'John Doe'\r\nend\r\n\r\n# creates an admin user with name \"John Doe\"\r\nFactoryGirl.create(:post).user\r\n```\r\n\r\nWhen you're using association names that're different than the factory:\r\n\r\n```ruby\r\nfactory :user do\r\n  name \"Friendly User\"\r\n\r\n  trait :admin do\r\n    admin true\r\n  end\r\nend\r\n\r\nfactory :post do\r\n  association :author, :admin, factory: :user, name: 'John Doe'\r\n  # or\r\n  association :author, factory: [:user, :admin], name: 'John Doe'\r\nend\r\n\r\n# creates an admin user with name \"John Doe\"\r\nFactoryGirl.create(:post).author\r\n```\r\nCallbacks\r\n---------\r\n\r\nfactory\\_girl makes available four callbacks for injecting some code:\r\n\r\n* after(:build)   - called after a factory is built   (via `FactoryGirl.build`, `FactoryGirl.create`)\r\n* before(:create) - called before a factory is saved  (via `FactoryGirl.create`)\r\n* after(:create)  - called after a factory is saved   (via `FactoryGirl.create`)\r\n* after(:stub)    - called after a factory is stubbed (via `FactoryGirl.build_stubbed`)\r\n\r\nExamples:\r\n\r\n```ruby\r\n# Define a factory that calls the generate_hashed_password method after it is built\r\nfactory :user do\r\n  after(:build) { |user| generate_hashed_password(user) }\r\nend\r\n```\r\n\r\nNote that you'll have an instance of the user in the block. This can be useful.\r\n\r\nYou can also define multiple types of callbacks on the same factory:\r\n\r\n```ruby\r\nfactory :user do\r\n  after(:build)  { |user| do_something_to(user) }\r\n  after(:create) { |user| do_something_else_to(user) }\r\nend\r\n```\r\n\r\nFactories can also define any number of the same kind of callback.  These callbacks will be executed in the order they are specified:\r\n\r\n```ruby\r\nfactory :user do\r\n  after(:create) { this_runs_first }\r\n  after(:create) { then_this }\r\nend\r\n```\r\n\r\nCalling FactoryGirl.create will invoke both `after_build` and `after_create` callbacks.\r\n\r\nAlso, like standard attributes, child factories will inherit (and can also define) callbacks from their parent factory.\r\n\r\nMultiple callbacks can be assigned to run a block; this is useful when building various strategies that run the same code (since there are no callbacks that are shared across all strategies).\r\n\r\n```ruby\r\nfactory :user do\r\n  callback(:after_stub, :before_create) { do_something }\r\n  after(:stub, :create) { do_something_else }\r\n  before(:create, :custom) { do_a_third_thing }\r\nend\r\n```\r\n\r\nModifying factories\r\n-------------------\r\n\r\nIf you're given a set of factories (say, from a gem developer) but want to change them to fit into your application better, you can\r\nmodify that factory instead of creating a child factory and adding attributes there.\r\n\r\nIf a gem were to give you a User factory:\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n  factory :user do\r\n    full_name \"John Doe\"\r\n    sequence(:username) {|n| \"user#{n}\" }\r\n    password \"password\"\r\n  end\r\nend\r\n```\r\n\r\nInstead of creating a child factory that added additional attributes:\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n  factory :application_user, parent: :user do\r\n    full_name     \"Jane Doe\"\r\n    date_of_birth { 21.years.ago }\r\n    gender        \"Female\"\r\n    health        90\r\n  end\r\nend\r\n```\r\n\r\nYou could modify that factory instead.\r\n\r\n```ruby\r\nFactoryGirl.modify do\r\n  factory :user do\r\n    full_name     \"Jane Doe\"\r\n    date_of_birth { 21.years.ago }\r\n    gender        \"Female\"\r\n    health        90\r\n  end\r\nend\r\n```\r\n\r\nWhen modifying a factory, you can change any of the attributes you want (aside from callbacks).\r\n\r\n`FactoryGirl.modify` must be called outside of a `FactoryGirl.define` block as it operates on factories differently.\r\n\r\nA caveat: you can only modify factories (not sequences or traits) and callbacks *still compound as they normally would*. So, if\r\nthe factory you're modifying defines an `after(:create)` callback, you defining an `after(:create)` won't override it, it'll just get run after the first callback.\r\n\r\nBuilding or Creating Multiple Records\r\n-------------------------------------\r\n\r\nSometimes, you'll want to create or build multiple instances of a factory at once.\r\n\r\n```ruby\r\nbuilt_users   = FactoryGirl.build_list(:user, 25)\r\ncreated_users = FactoryGirl.create_list(:user, 25)\r\n```\r\n\r\nThese methods will build or create a specific amount of factories and return them as an array.\r\nTo set the attributes for each of the factories, you can pass in a hash as you normally would.\r\n\r\n```ruby\r\ntwenty_year_olds = FactoryGirl.build_list(:user, 25, date_of_birth: 20.years.ago)\r\n```\r\n\r\nCustom Construction\r\n-------------------\r\n\r\nIf you want to use factory_girl to construct an object where some attributes\r\nare passed to `initialize` or if you want to do something other than simply\r\ncalling `new` on your build class, you can override the default behavior by\r\ndefining `initialize_with` on your factory. Example:\r\n\r\n```ruby\r\n# user.rb\r\nclass User\r\n  attr_accessor :name, :email\r\n\r\n  def initialize(name)\r\n    @name = name\r\n  end\r\nend\r\n\r\n# factories.rb\r\nsequence(:name) {|n| \"person#{n}@example.com\" }\r\n\r\nfactory :user do\r\n  ignore do\r\n    name \"Jane Doe\"\r\n  end\r\n\r\n  email\r\n  initialize_with { new(name) }\r\nend\r\n\r\nFactoryGirl.build(:user).name # Jane Doe\r\n```\r\n\r\nNotice that I ignored the `name` attribute. If you don't want attributes\r\nreassigned after your object has been instantiated, you'll want to `ignore` them.\r\n\r\nAlthough factory_girl is written to work with ActiveRecord out of the box, it\r\ncan also work with any Ruby class. For maximum compatibiltiy with ActiveRecord,\r\nthe default initializer builds all instances by calling new on your build class\r\nwithout any arguments. It then calls attribute writer methods to assign all the\r\nattribute values. While that works fine for ActiveRecord, it actually doesn't\r\nwork for almost any other Ruby class.\r\n\r\nYou can override the initializer in order to:\r\n\r\n* Build non-ActiveRecord objects that require arguments to `initialize`\r\n* Use a method other than `new` to instantiate the instance\r\n* Do crazy things like decorate the instance after it's built\r\n\r\nWhen using `initialize_with`, you don't have to declare the class itself when\r\ncalling `new`; however, any other class methods you want to call will have to\r\nbe called on the class explicitly.\r\n\r\nFor example:\r\n\r\n```ruby\r\nfactory :user do\r\n  ignore do\r\n    name \"John Doe\"\r\n  end\r\n\r\n  initialize_with { User.build_with_name(name) }\r\nend\r\n```\r\n\r\nYou can also access all public attributes within the `initialize_with` block\r\nby calling `attributes`:\r\n\r\n```ruby\r\nfactory :user do\r\n  ignore do\r\n    comments_count 5\r\n  end\r\n\r\n  name \"John Doe\"\r\n\r\n  initialize_with { new(attributes) }\r\nend\r\n```\r\n\r\nThis will build a hash of all attributes to be passed to `new`. It won't\r\ninclude ignored attributes, but everything else defined in the factory will be\r\npassed (associations, evalued sequences, etc.)\r\n\r\nYou can define `initialize_with` for all factories by including it in the\r\n`FactoryGirl.define` block:\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n  initialize_with { new(\"Awesome first argument\") }\r\nend\r\n```\r\n\r\nWhen using `initialize_with`, attributes accessed from within the `initialize_with`\r\nblock are assigned *only* in the constructor; this equates to roughly the\r\nfollowing code:\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n  factory :user do\r\n    initialize_with { new(name) }\r\n\r\n    name { 'value' }\r\n  end\r\nend\r\n\r\nFactoryGirl.build(:user)\r\n# runs\r\nUser.new('value')\r\n```\r\n\r\nThis prevents duplicate assignment; in versions of FactoryGirl before 4.0, it\r\nwould run this:\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n  factory :user do\r\n    initialize_with { new(name) }\r\n\r\n    name { 'value' }\r\n  end\r\nend\r\n\r\nFactoryGirl.build(:user)\r\n# runs\r\nuser = User.new('value')\r\nuser.name = 'value'\r\n```\r\n\r\nCustom Strategies\r\n-----------------\r\n\r\nThere are times where you may want to extend behavior of factory\\_girl by\r\nadding a custom build strategy.\r\n\r\nStrategies define two methods: `association` and `result`. `association`\r\nreceives a `FactoryGirl::FactoryRunner` instance, upon which you can call\r\n`run`, overriding the strategy if you want. The second method, `result`,\r\nreceives a `FactoryGirl::Evaluation` instance. It provides a way to trigger\r\ncallbacks (with `notify`), `object` or `hash` (to get the result instance or a\r\nhash based on the attributes defined in the factory), and `create`, which\r\nexecutes the `to_create` callback defined on the factory.\r\n\r\nTo understand how factory\\_girl uses strategies internally, it's probably\r\neasiest to just view the source for each of the four default strategies.\r\n\r\nHere's an example of composing a strategy using\r\n`FactoryGirl::Strategy::Create` to build a JSON representation of your model.\r\n\r\n```ruby\r\nclass JsonStrategy\r\n  def initialize\r\n    @strategy = FactoryGirl.strategy_by_name(:create).new\r\n  end\r\n\r\n  delegate :association, to: :@strategy\r\n\r\n  def result(evaluation)\r\n    @strategy.result(evaluation).to_json\r\n  end\r\nend\r\n```\r\n\r\nFor factory\\_girl to recognize the new strategy, you can register it:\r\n\r\n```ruby\r\nFactoryGirl.register_strategy(:json, JsonStrategy)\r\n```\r\n\r\nThis allows you to call\r\n\r\n```ruby\r\nFactoryGirl.json(:user)\r\n```\r\n\r\nFinally, you can override factory\\_girl's own strategies if you'd like by\r\nregistering a new object in place of the strategies.\r\n\r\nCustom Callbacks\r\n----------------\r\n\r\nCustom callbacks can be defined if you're using custom strategies:\r\n\r\n```ruby\r\nclass JsonStrategy\r\n  def initialize\r\n    @strategy = FactoryGirl.strategy_by_name(:create).new\r\n  end\r\n\r\n  delegate :association, to: :@strategy\r\n\r\n  def result(evaluation)\r\n    result = @strategy.result(evaluation)\r\n    evaluation.notify(:before_json, result)\r\n\r\n    result.to_json.tap do |json|\r\n      evaluation.notify(:after_json, json)\r\n      evaluation.notify(:make_json_awesome, json)\r\n    end\r\n  end\r\nend\r\n\r\nFactoryGirl.register_strategy(:json, JsonStrategy)\r\n\r\nFactoryGirl.define do\r\n  factory :user do\r\n    before(:json)                {|user| do_something_to(user) }\r\n    after(:json)                 {|user_json| do_something_to(user_json) }\r\n    callback(:make_json_awesome) {|user_json| do_something_to(user_json) }\r\n  end\r\nend\r\n```\r\n\r\nCustom Methods to Persist Objects\r\n---------------------------------\r\n\r\nBy default, creating a record will call `save!` on the instance; since this\r\nmay not always be ideal, you can override that behavior by defining\r\n`to_create` on the factory:\r\n\r\n```ruby\r\nfactory :different_orm_model do\r\n  to_create {|instance| instance.persist! }\r\nend\r\n```\r\n\r\nTo disable the persistence method altogether on create, you can `skip_create`\r\nfor that factory:\r\n\r\n```ruby\r\nfactory :user_without_database do\r\n  skip_create\r\nend\r\n```\r\n\r\nTo override `to_create` for all factories, define it within the\r\n`FactoryGirl.define` block:\r\n\r\n```ruby\r\nFactoryGirl.define do\r\n  to_create {|instance| instance.persist! }\r\n\r\n\r\n  factory :user do\r\n    name \"John Doe\"\r\n  end\r\nend\r\n```\r\n\r\nActiveSupport Instrumentation\r\n-----------------------------\r\n\r\nIn order to track what factories are created (and with what build strategy),\r\n`ActiveSupport::Notifications` are included to provide a way to subscribe to\r\nfactories being run. One example would be to track factories based on a\r\nthreshold of execution time.\r\n\r\n```ruby\r\nActiveSupport::Notifications.subscribe(\"factory_girl.run_factory\") do |name, start, finish, id, payload|\r\n  execution_time_in_seconds = finish - start\r\n\r\n  if execution_time_in_seconds >= 0.5\r\n    $stderr.puts \"Slow factory: #{payload[:name]} using strategy #{payload[:strategy]}\"\r\n  end\r\nend\r\n```\r\n\r\nAnother example would be tracking all factories and how they're used\r\nthroughout your test suite. If you're using RSpec, it's as simple as adding a\r\n`before(:suite)` and `after(:suite)`:\r\n\r\n```ruby\r\nconfig.before(:suite) do\r\n  @factory_girl_results = {}\r\n  ActiveSupport::Notifications.subscribe(\"factory_girl.run_factory\") do |name, start, finish, id, payload|\r\n    factory_name = payload[:name]\r\n    strategy_name = payload[:strategy]\r\n    @factory_girl_results[factory_name] ||= {}\r\n    @factory_girl_results[factory_name][strategy_name] ||= 0\r\n    @factory_girl_results[factory_name][strategy_name] += 1\r\n  end\r\nend\r\n\r\nconfig.after(:suite) do\r\n  puts @factory_girl_results\r\nend\r\n```\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Factory girl","tagline":"A library for setting up Ruby objects as test data.","google":""}