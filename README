= factory_girl

== Defining factories

  # This will guess the User class
  Factory.define :user do |u|
    u.first_name 'John'
    u.last_name  'Doe'
    u.admin false
  end

  # This will use the User class (Admin would have been guessed)
  Factory.define :admin, :class => User do |u|
    u.first_name 'Admin'
    u.last_name  'User'
    u.admin true
  end

It is recommended that you create a test/factories.rb file and define your
factories there. This file can be included from test_helper or directly from
your test files. Don't forget:
  require 'factory_girl'

== Lazy Attributes

Most attributes can be added using static values that are evaluated when the
factory is defined, but some attributes (such as associations and other
attributes that must be dynamically generated) will need values assigned each
time an instance is generated. These "lazy" attributes can be added by passing
a block instead of a parameter:

  Factory.define :user do |u|
    # ...
    u.activation_code { User.generate_activation_code }
  end

== Using factories

  # Build and save a User instance
  Factory(:user)

  # Build a User instance and override the first_name property
  Factory.build(:user, :first_name => 'Joe')

  # Return an attributes Hash that can be used to build a User instance
  attrs = Factory.attributes_for(:user)

== Associations

Associated instances can be generated by using the association method when
defining a lazy attribute:

  Factory.define :post do |p|
    # ...
    p.author {|author| author.association(:user, :last_name => 'Writely') }
  end

When using the association method, the same build strategy (build, create, or attributes_for) will be used for all generated instances:

  # Builds and saves a User and a Post
  post = Factory(:post)
  post.new_record?       # => false
  post.author.new_record # => false

  # Builds but does not save a User and a Post
  Factory.build(:post)
  post.new_record?       # => true
  post.author.new_record # => true
