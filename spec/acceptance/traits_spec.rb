describe "an instance generated by a factory with multiple traits" do
  before do
    define_model("Post",
                 name:          :string,
                 draft:         :boolean,
                 slug:          :string,
                 teaser:        :string,
                 published_on:  :date,
                 great:         :string)

    FactoryBot.define do
      factory :post_without_draft_scoping, class: Post do
        draft_trait
      end

      factory :post do
        name { "John" }

        trait :great do
          great { "GREAT!!!" }
        end

        trait :draft do
          draft { true }
        end

        trait :draft_trait do
          draft { true }
        end

        trait :night do
          name  { "Posted at Night" }
          slug  { "night" }
        end

        trait :morning do
          name   { "Posted in the Morning" }
          slug   { "morning" }
        end

        factory :great_post do
          great
        end

        factory :draft, traits: [:draft]

        factory :night_post do
          night

          factory :child_night_post do
            published_on { Date.parse("1/1/2000") }
          end
        end

        factory :morning, traits: [:morning] do
          trait :draft do
            draft { true }
            name { "Judy" }
          end

          factory :morning_great_post do
            great
          end

          factory :morning_draft_judy, traits: [:draft]
        end

        factory :morning_draft,            traits: [:morning, :draft]
        factory :morning_after_night_draft, traits: [:night, :morning, :draft]
        factory :night_after_morning_draft, traits: [:morning, :night, :draft]
      end

      trait :teaser do
        teaser { "with a teaser" }
      end

      factory :post_with_teaser, class: Post, traits: [:teaser] do
        name { "Bill" }
      end
    end
  end

  context "the parent class" do
    subject      { FactoryBot.create(:post) }
    its(:name)   { should eq "John" }
    its(:slug)   { should be_nil }
    it           { should_not be_draft }
  end

  context "the child class with one trait" do
    subject      { FactoryBot.create(:draft) }
    its(:name)   { should eq "John" }
    its(:slug) { should be_nil }
    it           { should be_draft }
  end

  context "the other child class with one trait" do
    subject      { FactoryBot.create(:morning) }
    its(:name)   { should eq "Posted in the Morning" }
    its(:slug)   { should eq "morning" }
    it           { should_not be_draft }
  end

  context "the child with multiple traits" do
    subject      { FactoryBot.create(:morning_draft) }
    its(:name)   { should eq "Posted in the Morning" }
    its(:slug)   { should eq "morning" }
    it           { should be_draft }
  end

  context "the child with multiple traits and overridden attributes" do
    subject      { FactoryBot.create(:morning_draft, name: "Jill", slug: nil) }
    its(:name)   { should eq "Jill" }
    its(:slug)   { should be_nil }
    it           { should be_draft }
  end

  context "the child with multiple traits who override the same attribute" do
    context "when the night assigns name after morning" do
      subject      { FactoryBot.create(:night_after_morning_draft) }
      its(:name)   { should eq "Posted at Night" }
      its(:slug)   { should eq "night" }
      it           { should be_draft }
    end

    context "when the morning assigns name after night" do
      subject      { FactoryBot.create(:morning_after_night_draft) }
      its(:name)   { should eq "Posted in the Morning" }
      its(:slug)   { should eq "morning" }
      it           { should be_draft }
    end
  end

  context "child class with scoped trait and inherited trait" do
    subject      { FactoryBot.create(:morning_draft_judy) }
    its(:name)   { should eq "Judy" }
    its(:slug)   { should eq "morning" }
    it           { should be_draft }
  end

  context "factory using global trait" do
    subject       { FactoryBot.create(:post_with_teaser) }
    its(:name)    { should eq "Bill" }
    its(:teaser)  { should eq "with a teaser" }
  end

  context "factory created with alternate syntax for specifying trait" do
    subject      { FactoryBot.create(:night_post) }
    its(:slug)   { should eq "night" }

    context "where trait name and attribute are the same" do
      subject     { FactoryBot.create(:great_post) }
      its(:great) { should eq "GREAT!!!" }
    end

    context "where trait name and attribute are the same and attribute is overridden" do
      subject     { FactoryBot.create(:great_post, great: "SORT OF!!!") }
      its(:great) { should eq "SORT OF!!!" }
    end
  end

  context "child factory created where trait attributes are inherited" do
    subject             { FactoryBot.create(:child_night_post) }
    its(:slug)          { should eq "night" }
    its(:published_on)  { should eq Date.parse("1/1/2000") }
  end

  context "factory outside of scope" do
    subject { FactoryBot.create(:post_without_draft_scoping) }

    it "raises an error" do
      expect { subject }.
        to raise_error(KeyError, "Trait not registered: \"draft_trait\"")
    end
  end

  context "child factory using grandparents' trait" do
    subject     { FactoryBot.create(:morning_great_post) }
    its(:great) { should eq "GREAT!!!" }
  end
end

describe "trait indifferent access" do
  context "when trait is defined as a string" do
    it "can be invoked with a string" do
      build_post_factory_with_draft_trait("draft")

      post = FactoryBot.build(:post, "draft")

      expect(post).to be_draft
    end

    it "can be invoked with a symbol" do
      build_post_factory_with_draft_trait("draft")

      post = FactoryBot.build(:post, :draft)

      expect(post).to be_draft
    end
  end

  context "when trait is defined as a symbol" do
    it "can be invoked with a string" do
      build_post_factory_with_draft_trait(:draft)

      post = FactoryBot.build(:post, "draft")

      expect(post).to be_draft
    end

    it "can be invoked with a symbol" do
      build_post_factory_with_draft_trait(:draft)

      post = FactoryBot.build(:post, :draft)

      expect(post).to be_draft
    end
  end

  def build_post_factory_with_draft_trait(trait_name)
    define_model("Post", draft: :boolean)

    FactoryBot.define do
      factory :post do
        draft { false }

        trait trait_name do
          draft { true }
        end
      end
    end
  end
end

describe "looking up traits that don't exist" do
  it "raises a KeyError" do
    define_class("Post")

    FactoryBot.define do
      factory :post
    end

    expect { FactoryBot.build(:post, double("not a trait")) }.
      to raise_error(KeyError)
  end
end

describe "traits with callbacks" do
  before do
    define_model("Post", name: :string)

    FactoryBot.define do
      factory :post do
        name { "A Post" }

        trait :great do
          after(:create) { |post| post.name.upcase! }
        end

        trait :awesome do
          after(:create) { |post| post.name = "awesome" }
        end

        factory :caps_post, traits: [:great]
        factory :awesome_post, traits: [:great, :awesome]

        factory :caps_post_implicit_trait do
          great
        end
      end
    end
  end

  context "when the factory has a trait passed via arguments" do
    subject    { FactoryBot.create(:caps_post) }
    its(:name) { should eq "A POST" }
  end

  context "when the factory has an implicit trait" do
    subject    { FactoryBot.create(:caps_post_implicit_trait) }
    its(:name) { should eq "A POST" }
  end

  it "executes callbacks in the order assigned" do
    expect(FactoryBot.create(:awesome_post).name).to eq "awesome"
  end
end

describe "traits added via strategy" do
  before do
    define_model("Post", name: :string, draft: :boolean)

    FactoryBot.define do
      factory :post do
        name { "A Post" }

        trait :draft do
          draft { true }
        end

        trait :great do
          after(:create) { |post| post.name.upcase! }
        end
      end
    end
  end

  context "adding traits in create" do
    subject { FactoryBot.create(:post, :draft, :great, name: "B Post") }

    its(:draft) { should be true }
    its(:name)  { should eq "B POST" }

    it "doesn't modify the post factory" do
      subject
      expect(FactoryBot.create(:post)).not_to be_draft
      expect(FactoryBot.create(:post).name).to eq "A Post"
    end
  end

  context "adding traits in build" do
    subject { FactoryBot.build(:post, :draft, :great, name: "B Post") }

    its(:draft) { should be true }
    its(:name)  { should eq "B Post" }
  end

  context "adding traits in attributes_for" do
    subject { FactoryBot.attributes_for(:post, :draft, :great) }

    its([:draft]) { should be true }
    its([:name])  { should eq "A Post" }
  end

  context "adding traits in build_stubbed" do
    subject { FactoryBot.build_stubbed(:post, :draft, :great, name: "Blog Post") }

    its(:draft) { should be true }
    its(:name)  { should eq "Blog Post" }
  end

  context "adding traits in create_list" do
    subject { FactoryBot.create_list(:post, 2, :draft, :great, name: "Blog") }

    its(:length) { should eq 2 }

    it "creates all the records" do
      subject.each do |record|
        expect(record.draft).to be true
        expect(record.name).to eq "BLOG"
      end
    end
  end

  context "adding traits in build_list" do
    subject { FactoryBot.build_list(:post, 2, :draft, :great, name: "Blog") }

    its(:length) { should eq 2 }

    it "builds all the records" do
      subject.each do |record|
        expect(record.draft).to be true
        expect(record.name).to eq "Blog"
      end
    end
  end
end

describe "traits and dynamic attributes that are applied simultaneously" do
  before do
    define_model("Post", name: :string, published_on: :date, combined: :string)

    FactoryBot.define do
      trait :published_on_y2k do
        published_on { Date.parse("2000/01/01") }
      end

      factory :post do
        name { "Post" }
        published_on_y2k
        combined { "#{name} <#{published_on.year}>" }
      end
    end
  end

  subject            { FactoryBot.build(:post) }
  its(:name)         { should eq "Post" }
  its(:published_on) { should eq Date.parse("2000/01/01") }
  its(:combined)     { should eq "Post <2000>" }
end

describe "applying inline traits" do
  before do
    define_model("Post") do
      has_many :tags
    end

    define_model("Tag", post_id: :integer) do
      belongs_to :post
    end

    FactoryBot.define do
      factory :post do
        trait :with_tags do
          tags { [Tag.new] }
        end
      end
    end
  end

  it "applies traits only to the instance generated for that call" do
    expect(FactoryBot.create(:post, :with_tags).tags).not_to be_empty
    expect(FactoryBot.create(:post).tags).to be_empty
    expect(FactoryBot.create(:post, :with_tags).tags).not_to be_empty
  end
end

describe "inline traits overriding existing attributes" do
  before do
    define_model("Request", status: :string)

    FactoryBot.define do
      factory :request do
        status { "pending" }

        trait(:accepted) { status { "accepted" } }
        trait(:declined) { status { "declined" } }

        factory :declined_request, traits: [:declined]
        factory :extended_declined_request, traits: [:declined] do
          status { "extended_declined" }
        end
      end
    end
  end

  it "returns the default status" do
    expect(FactoryBot.build(:request).status).to eq "pending"
  end

  it "prefers inline trait attributes over default attributes" do
    expect(FactoryBot.build(:request, :accepted).status).to eq "accepted"
  end

  it "prefers traits on a factory over default attributes" do
    expect(FactoryBot.build(:declined_request).status).to eq "declined"
  end

  it "prefers inline trait attributes over traits on a factory" do
    expect(FactoryBot.build(:declined_request, :accepted).status).to eq "accepted"
  end

  it "prefers attributes on factories over attributes from non-inline traits" do
    expect(FactoryBot.build(:extended_declined_request).status).to eq "extended_declined"
  end

  it "prefers inline traits over attributes on factories" do
    expect(FactoryBot.build(:extended_declined_request, :accepted).status).to eq "accepted"
  end

  it "prefers overridden attributes over attributes from traits, inline traits, or attributes on factories" do
    request = FactoryBot.build(:extended_declined_request, :accepted, status: "completely overridden")

    expect(request.status).to eq "completely overridden"
  end
end

describe "making sure the factory is properly compiled the first time we want to instantiate it" do
  before do
    define_model("Post", draft: :boolean, published_on: :date, age: :integer)

    FactoryBot.define do
      factory :post do
        trait(:published_on_y2k) { published_on { Date.parse("2000/01/01") } }
        trait(:draft) { draft { true } }

        factory :y2k_post do
          published_on_y2k
        end
      end
    end
  end

  it "can honor traits on the very first call" do
    post = FactoryBot.build(:y2k_post, :draft, age: 30)
    expect(post.published_on).to eq Date.parse("2000/01/01")
    expect(post.age).to eq 30
    expect(post.draft).to be true
  end
end

describe "traits with to_create" do
  before do
    define_model("Post", name: :string)

    FactoryBot.define do
      factory :post do
        trait :with_to_create do
          to_create { |instance| instance.name = "to_create" }
        end

        factory :sub_post do
          to_create { |instance| instance.name = "sub" }

          factory :child_post
        end

        factory :sub_post_with_trait do
          with_to_create

          factory :child_post_with_trait
        end

        factory :sub_post_with_trait_and_override do
          with_to_create
          to_create { |instance| instance.name = "sub with trait and override" }

          factory :child_post_with_trait_and_override
        end
      end
    end
  end

  it "can apply to_create from traits" do
    expect(FactoryBot.create(:post, :with_to_create).name).to eq "to_create"
  end

  it "can apply to_create from the definition" do
    expect(FactoryBot.create(:sub_post).name).to eq "sub"
    expect(FactoryBot.create(:child_post).name).to eq "sub"
  end

  it "gives additional traits higher priority than to_create from the definition" do
    expect(FactoryBot.create(:sub_post, :with_to_create).name).to eq "to_create"
    expect(FactoryBot.create(:child_post, :with_to_create).name).to eq "to_create"
  end

  it "gives base traits normal priority" do
    expect(FactoryBot.create(:sub_post_with_trait).name).to eq "to_create"
    expect(FactoryBot.create(:child_post_with_trait).name).to eq "to_create"
  end

  it "gives base traits lower priority than overrides" do
    expect(FactoryBot.create(:sub_post_with_trait_and_override).name).to eq "sub with trait and override"
    expect(FactoryBot.create(:child_post_with_trait_and_override).name).to eq "sub with trait and override"
  end

  it "gives additional traits higher priority than base traits and factory definition" do
    FactoryBot.define do
      trait :overridden do
        to_create { |instance| instance.name = "completely overridden" }
      end
    end

    sub_post = FactoryBot.create(:sub_post_with_trait_and_override, :overridden)
    child_post = FactoryBot.create(:child_post_with_trait_and_override, :overridden)
    expect(sub_post.name).to eq "completely overridden"
    expect(child_post.name).to eq "completely overridden"
  end
end

describe "traits with initialize_with" do
  before do
    define_class("Post") do
      attr_reader :name

      def initialize(name)
        @name = name
      end
    end

    FactoryBot.define do
      factory :post do
        trait :with_initialize_with do
          initialize_with { new("initialize_with") }
        end

        factory :sub_post do
          initialize_with { new("sub") }

          factory :child_post
        end

        factory :sub_post_with_trait do
          with_initialize_with

          factory :child_post_with_trait
        end

        factory :sub_post_with_trait_and_override do
          with_initialize_with
          initialize_with { new("sub with trait and override") }

          factory :child_post_with_trait_and_override
        end
      end
    end
  end

  it "can apply initialize_with from traits" do
    expect(FactoryBot.build(:post, :with_initialize_with).name).to eq "initialize_with"
  end

  it "can apply initialize_with from the definition" do
    expect(FactoryBot.build(:sub_post).name).to eq "sub"
    expect(FactoryBot.build(:child_post).name).to eq "sub"
  end

  it "gives additional traits higher priority than initialize_with from the definition" do
    expect(FactoryBot.build(:sub_post, :with_initialize_with).name).to eq "initialize_with"
    expect(FactoryBot.build(:child_post, :with_initialize_with).name).to eq "initialize_with"
  end

  it "gives base traits normal priority" do
    expect(FactoryBot.build(:sub_post_with_trait).name).to eq "initialize_with"
    expect(FactoryBot.build(:child_post_with_trait).name).to eq "initialize_with"
  end

  it "gives base traits lower priority than overrides" do
    expect(FactoryBot.build(:sub_post_with_trait_and_override).name).to eq "sub with trait and override"
    expect(FactoryBot.build(:child_post_with_trait_and_override).name).to eq "sub with trait and override"
  end

  it "gives additional traits higher priority than base traits and factory definition" do
    FactoryBot.define do
      trait :overridden do
        initialize_with { new("completely overridden") }
      end
    end

    sub_post = FactoryBot.build(:sub_post_with_trait_and_override, :overridden)
    child_post = FactoryBot.build(:child_post_with_trait_and_override, :overridden)
    expect(sub_post.name).to eq "completely overridden"
    expect(child_post.name).to eq "completely overridden"
  end
end

describe "nested implicit traits" do
  before do
    define_class("Post") do
      attr_accessor :draft, :name, :published_on

      def initialize(name)
        @name = name
      end
    end
  end

  shared_examples_for "assigning data from traits" do
    it "assigns the correct values" do
      post = FactoryBot.create(:post, :y2k_draft)
      expect(post.published_on).to eq Date.parse("2000/01/01")
      expect(post.draft).to be true
      expect(post.name).to eq "DRAFT: Y2K"
    end
  end

  context "defined outside the factory" do
    before do
      FactoryBot.define do
        trait :published_on_y2k do
          published_on { Date.parse("1999/12/31") }
          to_create { |instance| instance.published_on = instance.published_on + 1.day }
        end

        trait :named_y2k do
          initialize_with { new("Y2K") }
        end

        trait :draft do
          draft { true }
          after(:build) { |instance| instance.name = "DRAFT: #{instance.name}" }
        end

        trait :y2k_draft do
          published_on_y2k
          draft
          named_y2k
        end

        factory :post
      end
    end

    it_should_behave_like "assigning data from traits"
  end

  context "defined inside the factory" do
    before do
      FactoryBot.define do
        factory :post do
          trait :published_on_y2k do
            published_on { Date.parse("1999/12/31") }
            to_create { |instance| instance.published_on = instance.published_on + 1.day }
          end

          trait :named_y2k do
            initialize_with { new("Y2K") }
          end

          trait :draft do
            draft { true }
            after(:build) { |instance| instance.name = "DRAFT: #{instance.name}" }
          end

          trait :y2k_draft do
            published_on_y2k
            draft
            named_y2k
          end
        end
      end
    end

    it_should_behave_like "assigning data from traits"
  end
end

describe "implicit traits containing callbacks" do
  before do
    define_model("Post", value: :integer)

    FactoryBot.define do
      factory :post do
        value { 0 }

        trait :trait_with_callback do
          after(:build) { |post| post.value += 1 }
        end

        factory :post_with_trait_with_callback do
          trait_with_callback
        end
      end
    end
  end

  it "only runs the callback once" do
    expect(FactoryBot.build(:post_with_trait_with_callback).value).to eq 1
  end
end

describe "traits used in associations" do
  before do
    define_model("Post", published: :boolean, name: :string)

    define_model("Comment", post_id: :integer) do
      belongs_to :post
    end

    define_model("Order", promotional_post_id: :integer) do
      belongs_to :promotional_post, class_name: "Post"
    end

    define_model("Image", post_id: :integer) do
      belongs_to :post, class_name: "Post"
    end

    FactoryBot.define do
      factory :post do
        published { false }

        trait :published do
          published { true }
        end
      end

      factory :image do
        association :post, factory: [:post, :published], name: "With Image"
      end

      factory :comment do
        association :post, :published, name: "With Comment"
      end

      factory :order do
        association :promotional_post, :published, factory: :post, name: "With Order"
      end
    end
  end

  it "allows assigning traits for the factory of an association" do
    post = FactoryBot.create(:image).post
    expect(post).to be_published
    expect(post.name).to eq "With Image"
  end

  it "allows inline traits with the default association" do
    post = FactoryBot.create(:comment).post
    expect(post).to be_published
    expect(post.name).to eq "With Comment"
  end

  it "allows inline traits with a specific factory for an association" do
    promotional_post = FactoryBot.create(:order).promotional_post
    expect(promotional_post).to be_published
    expect(promotional_post.name).to eq "With Order"
  end
end
